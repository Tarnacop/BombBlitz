package bomber.networking;

import java.net.DatagramPacket;
import java.net.SocketAddress;
import java.time.Instant;
import java.util.ArrayList;

/**
 * Server side representation of (the state of) a client
 */
public class ServerClientInfo {
	// socket address (IP:Port) of the client
	private SocketAddress sockAddr;

	// name of the player
	// currently hard-coded to "default"
	private String name = "default";

	// id of the player
	// randomly generated by server
	// currently hard-coded to 0
	private int id = 0;

	// time of last packet received from the client in seconds
	private long timeStamp;

	// route trip delay of the client in milliseconds (measured by time of
	// acknowledgement)
	private long roundTripDelay;

	// the next sequence number that should be used for a packet that will be
	// sent to the client
	private short nextPacketSequence = 0;

	// keep track of up to 100 packets sent to the client
	private int nextPacketHistoryListIndex = 0;
	private final int maxPacketHistoryIndex = 99;
	private ArrayList<PacketHistoryEntry> packetHistoryList = new ArrayList<PacketHistoryEntry>(
			maxPacketHistoryIndex + 1);

	/**
	 * Construct a new client representation
	 * 
	 * @param sockAddr
	 *            the socket address of the client
	 */
	public ServerClientInfo(SocketAddress sockAddr) {
		this.sockAddr = sockAddr;
		this.timeStamp = Instant.now().getEpochSecond();
		for (int i = 0; i <= maxPacketHistoryIndex; i++) {
			packetHistoryList.add(null);
		}
	}

	/**
	 * Get the socket address (IP:Port) of the client
	 * 
	 * @return the socket address
	 */
	public SocketAddress getSocketAddress() {
		return sockAddr;
	}

	/**
	 * Get the name of the client
	 * 
	 * @return the name of the client
	 */
	public String getName() {
		return name;
	}

	/**
	 * Get the id of the client
	 * 
	 * @return the id of the client
	 */
	public int getID() {
		return id;
	}

	/**
	 * Get time of last packet received from the client in seconds
	 * 
	 * @return the time in seconds
	 */
	public long getTimeStamp() {
		return timeStamp;
	}

	/**
	 * Get round trip delay of the client in milliseconds
	 * 
	 * @return the delay in milliseconds
	 */
	public long getRoundTripDelay() {
		return roundTripDelay;
	}

	/**
	 * Get the sequence number that should be used for the next packet to the
	 * client and increment the counter
	 * 
	 * @return the sequence number that should be used
	 */
	public short getNextPacketSequenceAndIncrement() {
		return nextPacketSequence++;
	}

	/**
	 * Get the list of up to 100 recent packets that have been sent to the
	 * client
	 * 
	 * @return the list of packets that have been sent to the client
	 */
	public ArrayList<PacketHistoryEntry> getPacketHistoryList() {
		return packetHistoryList;
	}

	/**
	 * Set the name of the client
	 * 
	 * @param name
	 *            the name of the client
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Set the id of the client
	 * 
	 * @param id
	 *            the id of the client
	 */
	public void setID(int id) {
		this.id = id;
	}

	/**
	 * Set round trip delay of the client in milliseconds Should be called each
	 * time an acknowledgement packet is received from the client
	 * 
	 * @param delay
	 *            the delay in milliseconds
	 */
	public void setRoundTripDelay(long delay) {
		this.roundTripDelay = delay;
	}

	/**
	 * Update the time of last packet received from the client in seconds Should
	 * be called each time a packet is received from the client
	 */
	public void updateTimeStamp() {
		this.timeStamp = Instant.now().getEpochSecond();
	}

	/**
	 * Insert a packet into the packet history list for later retransmission (in
	 * case not acknowledged by the client)
	 * 
	 * @param packetSequence
	 *            the sequence number of the packet
	 * @param packet
	 *            the packet to insert
	 */
	public void insertPacket(short packetSequence, DatagramPacket packet) {
		// index wraps around when there are already 100 packets in history
		// (older packets will be overwritten)
		if (nextPacketHistoryListIndex > maxPacketHistoryIndex) {
			nextPacketHistoryListIndex = 0;
		}

		PacketHistoryEntry phe = packetHistoryList.get(nextPacketHistoryListIndex);
		if (phe == null) {
			packetHistoryList.set(nextPacketHistoryListIndex,
					new PacketHistoryEntry(packetSequence, packet.getData(), packet.getLength()));
		} else {
			phe.reset(packetSequence, packet.getData(), packet.getLength());
		}

		nextPacketHistoryListIndex++;
	}

	public String toString() {
		return String.format("SocketAddress: %s, TimeStamp: %d", sockAddr, timeStamp);
	}
}
